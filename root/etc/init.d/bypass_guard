#!/bin/sh /etc/rc.common
USE_PROCD=1
START=90
EXTRA_COMMANDS="refresh_nft sync_clients manage_natmap inject_bypass_rule update_chnroute"
CONF="advanced"
SECTION="global"
PSW_DEAD_FLAG="/tmp/psw_dead"
CHNROUTE_V4="https://ispip.clang.cn/all_cn.txt"
CHNROUTE_V6="https://ispip.clang.cn/all_cn_ipv6.txt"
readonly LAN_IF=$(uci -q get network.lan.device || uci -q get network.lan.ifname || echo "br-lan")
readonly WAN_IF=$(uci -q get network.wan.device || uci -q get network.wan.ifname || echo "wan")

is_chains_ready() {
    nft list chain inet passwall2 mangle_prerouting >/dev/null 2>&1 && \
    nft list chain inet passwall2 dstnat >/dev/null 2>&1
}

update_chnroute() {
    local force="$1"
    local table="bypass_logic"
    local count_v4=$(nft list set inet $table china_v4 2>/dev/null | grep -c "element")
    local count_v6=$(nft list set inet $table china_v6 2>/dev/null | grep -c "element")
    local need_v4=0; [ "$force" = "1" ] || [ "$count_v4" -lt 10 ] && need_v4=1
    local need_v6=0; [ "$force" = "1" ] || [ "$count_v6" -lt 10 ] && need_v6=1

    [ "$need_v4" -eq 0 ] && [ "$need_v6" -eq 0 ] && return 0

    logger -t bypass_guard "Populating China IP sets (v4:$need_v4 v6:$need_v6)..."
    {
        if [ "$need_v4" -eq 1 ]; then
            echo "flush set inet $table china_v4"
            curl -sL --connect-timeout 5 "$CHNROUTE_V4" | grep -E '^[0-9]{1,3}\.' | sed "s/^/add element inet $table china_v4 { /; s/$/ }/"
        fi
        if [ "$need_v6" -eq 1 ]; then
            echo "flush set inet $table china_v6"
            curl -sL --connect-timeout 5 "$CHNROUTE_V6" | grep -E '^[0-9a-fA-F:]' | sed "s/^/add element inet $table china_v6 { /; s/$/ }/"
        fi
    } | nft -f - 2>/dev/null
    
    if [ $? -eq 0 ]; then
        logger -t bypass_guard "China IP sets synchronized successfully."
    else
        logger -t bypass_guard "Error: Failed to inject IP sets into kernel."
    fi
}

remove_bypass_rules() {
    local table="passwall2"
    nft list table inet "$table" >/dev/null 2>&1 || return 0
    local cleaned=0
    for chain in "mangle_prerouting" "dstnat"; do
        nft list chain inet "$table" "$chain" >/dev/null 2>&1 || continue
        local handles=$(nft -a list chain inet "$table" "$chain" 2>/dev/null | grep -E "Bypass-Global-Mark" | awk -F '# handle ' '{print $2}')
        if [ -n "$handles" ]; then
            for handle in $handles; do
                nft delete rule inet "$table" "$chain" handle "$handle" 2>/dev/null
                cleaned=$((cleaned + 1))
            done
        fi
    done
    [ "$cleaned" -gt 0 ] && logger -t bypass_guard "Cleaned up $cleaned residual rules from passwall2."
}

inject_bypass_rule() {
    local table="passwall2"
    local mark="0x000000ff"
    local chain="$1"
    local comment="Bypass-Global-Mark"
    local retries=3
    local current_first=$(nft list chain inet "$table" "$chain" 2>/dev/null | sed -n '4p' | xargs)
    if [ -n "$current_first" ] && echo "$current_first" | grep -q "$comment"; then
        return 0
    fi
    while [ $retries -gt 0 ]; do
        if nft insert rule inet "$table" "$chain" index 0 meta mark "$mark" counter return comment "$comment" 2>/dev/null; then
            local old_handles=$(nft -a list chain inet "$table" "$chain" 2>/dev/null | grep "$comment" | grep -v "chain" | tail -n +2 | grep -oE 'handle [0-9]+' | awk '{print $2}')
            for handle in $old_handles; do
                [ -n "$handle" ] && nft delete rule inet "$table" "$chain" handle "$handle" 2>/dev/null
            done
            return 0
        fi
        retries=$((retries - 1))
        [ $retries -gt 0 ] && sleep 1
    done
    return 1
}

setup_nft() {
    local is_broken=0
    [ -f "$PSW_DEAD_FLAG" ] && is_broken=1
    local psw_online=$(nft list table inet passwall2 >/dev/null 2>&1 && echo 1 || echo 0)

    nft add table inet bypass_logic 2>/dev/null
    if ! nft list chain inet bypass_logic static_privilege >/dev/null 2>&1; then
        nft "add chain inet bypass_logic static_privilege { type filter hook prerouting priority -410; policy accept; }" 2>/dev/null
    fi

    nft "add set inet bypass_logic quic_direct_clients { type ipv4_addr; flags timeout; }" 2>/dev/null
    nft "add set inet bypass_logic quic_direct_clients6 { type ipv6_addr; }" 2>/dev/null
    nft "add set inet bypass_logic qb_dynamic_ports { type inet_service; flags timeout; }" 2>/dev/null
    nft "add set inet bypass_logic qb_outer_ports { type inet_service; }" 2>/dev/null
    nft "add set inet bypass_logic china_v4 { type ipv4_addr; flags interval; }" 2>/dev/null
    nft "add set inet bypass_logic china_v6 { type ipv6_addr; flags interval; }" 2>/dev/null

    if ! nft list chain inet bypass_logic static_privilege | grep -q "CN-v4-Direct"; then
        nft add rule inet bypass_logic static_privilege iifname "$LAN_IF" ip daddr @china_v4 counter meta mark set 0xff accept comment "CN-v4-Direct"
    fi
    if ! nft list chain inet bypass_logic static_privilege | grep -q "CN-v6-Direct"; then
        nft add rule inet bypass_logic static_privilege iifname "$LAN_IF" ip6 daddr @china_v6 counter meta mark set 0xff accept comment "CN-v6-Direct"
    fi
    if ! nft list table inet bypass_logic | grep -q "CF-Tunnel-tcp-Direct"; then
        nft add rule inet bypass_logic static_privilege ip saddr @quic_direct_clients tcp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel-tcp-Direct"
    fi
    if ! nft list table inet bypass_logic | grep -q "CF-Tunnel-udp-Direct"; then
        nft add rule inet bypass_logic static_privilege ip saddr @quic_direct_clients udp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel-udp-Direct"
    fi
    if ! nft list table inet bypass_logic | grep -q "CF-Tunnel6-tcp-Direct"; then
        nft add rule inet bypass_logic static_privilege ip6 saddr @quic_direct_clients6 tcp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel6-tcp-Direct"
    fi
    if ! nft list table inet bypass_logic | grep -q "CF-Tunnel6-udp-Direct"; then
        nft add rule inet bypass_logic static_privilege ip6 saddr @quic_direct_clients6 udp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel6-udp-Direct"
    fi
    if ! nft list table inet bypass_logic | grep -q "qB-tcp-Inbound-Mark-Direct"; then
        nft add rule inet bypass_logic static_privilege iifname "$WAN_IF" tcp dport @qb_outer_ports counter meta mark set 0xff accept comment "qB-tcp-Inbound-Mark-Direct"
    fi
    if ! nft list table inet bypass_logic | grep -q "qB-udp-Inbound-Mark-Direct"; then
        nft add rule inet bypass_logic static_privilege iifname "$WAN_IF" udp dport @qb_outer_ports counter meta mark set 0xff accept comment "qB-udp-Inbound-Mark-Direct"
    fi
    if ! nft list table inet bypass_logic | grep -q "qB-tcp-dport-Direct"; then
        nft add rule inet bypass_logic static_privilege tcp dport @qb_dynamic_ports counter meta mark set 0xff accept comment "qB-tcp-dport-Direct"
    fi
    if ! nft list table inet bypass_logic | grep -q "qB-tcp-sport-Direct"; then
        nft add rule inet bypass_logic static_privilege tcp sport @qb_dynamic_ports counter meta mark set 0xff accept comment "qB-tcp-sport-Direct"
    fi
    if ! nft list table inet bypass_logic | grep -q "qB-udp-dport-Direct"; then
        nft add rule inet bypass_logic static_privilege udp dport @qb_dynamic_ports counter meta mark set 0xff accept comment "qB-udp-dport-Direct"
    fi
    if ! nft list table inet bypass_logic | grep -q "qB-udp-sport-Direct"; then
        nft add rule inet bypass_logic static_privilege udp sport @qb_dynamic_ports counter meta mark set 0xff accept comment "qB-udp-sport-Direct"
    fi

    nft "add set inet bypass_logic psw_vpn_clients { type ipv4_addr; flags timeout; }" 2>/dev/null
    nft "add set inet bypass_logic psw_vpn_clients6 { type ipv6_addr; }" 2>/dev/null

    if ! nft list chain inet bypass_logic dynamic_logic >/dev/null 2>&1; then
        nft "add chain inet bypass_logic dynamic_logic { type filter hook prerouting priority -400; policy accept; }"
    fi

    nft flush chain inet bypass_logic dynamic_logic

    if ! nft list chain inet bypass_logic qb_fix >/dev/null 2>&1; then
        nft "add chain inet bypass_logic qb_fix { type nat hook prerouting priority -110; }"
    fi

    nft add rule inet bypass_logic dynamic_logic fib daddr type local meta mark != 0xff counter return comment "Local-Fix"

    local lan_addr=$(uci -q get network.lan.ipaddr)
    if [ -n "$lan_addr" ]; then
        case "$lan_addr" in
            */*) ;; 
            *) lan_addr="${lan_addr}/24" ;;
        esac
        nft add rule inet bypass_logic dynamic_logic ip daddr "$lan_addr" counter return comment "Loopback-Fix"
    fi

    local lan_addr6=$(ip -6 addr show dev "$LAN_IF" | grep 'scope global' | awk '{print $2}' | head -n1)
    if [ -n "$lan_addr6" ]; then
        nft add rule inet bypass_logic dynamic_logic ip6 daddr "$lan_addr6" counter return comment "Loopback-v6-Fix"
    fi

    if [ "$is_broken" -eq 0 ] && [ "$psw_online" -eq 1 ]; then
        nft add rule inet bypass_logic dynamic_logic ip saddr @psw_vpn_clients counter meta mark set 0 accept comment "AGENT-PASS"
        nft add rule inet bypass_logic dynamic_logic ip6 saddr @psw_vpn_clients6 counter meta mark set 0 accept comment "AGENT-PASS-V6"
        logger -t bypass_guard "ðŸš€ Mode: [PROXY] - Redirecting VPN clients to PassWall2 âœ…"
    else
        logger -t bypass_guard "ðŸ›¡ï¸ Mode: [BYPASS] - PassWall2 is unavailable âš ï¸"
    fi

    nft add rule inet bypass_logic dynamic_logic iifname "$LAN_IF" counter meta mark set 0xff accept comment "Global-Bypass-PassWall2"

    if is_chains_ready; then
        if nft list chain inet passwall2 mangle_prerouting 2>/dev/null | grep -q "Bypass-Global-Mark" && \
            nft list chain inet passwall2 dstnat 2>/dev/null | grep -q "Bypass-Global-Mark"; then
            return 0
        fi
        remove_bypass_rules
        local success=0
        inject_bypass_rule "mangle_prerouting" && success=$((success + 1))
        inject_bypass_rule "dstnat" && success=$((success + 1))
        [ "$success" -eq 2 ] && logger -t bypass_guard "ðŸ’‰ Successfully injected all bypass rules into PassWall2 ðŸ’¥"
    fi
}

sync_clients() {
    config_load "$CONF"
    config_load "dhcp"
    local vpn_sections=$(uci show dhcp | grep "@host" | grep "\.tag" | grep -i "VPN" | cut -d. -f2 | sort -u)
    local v6_prefix=$(ip -6 addr show dev "$LAN_IF" | grep 'scope global' | awk '{print $2}' | cut -d: -f1-4 | head -n1)

    if [ -z "$vpn_sections" ]; then
        logger -t bypass_guard "Sync: No VPN tagged hosts detected."
        return
    fi

    {
        echo "flush set inet bypass_logic psw_vpn_clients6"
        echo "flush set inet bypass_logic quic_direct_clients6"

        for section in $vpn_sections; do
            local tags=$(uci -q get dhcp.$section.tag)
            local is_server=$(echo "$tags" | grep -iw "server")

            local ips=$(uci -q get dhcp.$section.ip)
            for ip in $ips; do
                [ -z "$ip" ] && continue
                echo "add element inet bypass_logic psw_vpn_clients { $ip timeout 8d }"
                [ -n "$is_server" ] && echo "add element inet bypass_logic quic_direct_clients { $ip timeout 8d }"
            done

            local macs=$(uci -q get "dhcp.$section.mac")
            for mac in $macs; do
                local active_ips=$(ip neigh show | grep -i "$mac" | grep -E "REACHABLE|STALE|DELAY" | awk '{print $1}' | grep -v '^fe80')
                for ip in $active_ips; do
                    if echo "$ip" | grep -q ':'; then
                        echo "add element inet bypass_logic psw_vpn_clients6 { $ip }"
                        [ -n "$is_server" ] && echo "add element inet bypass_logic quic_direct_clients6 { $ip }"
                    else
                        echo "add element inet bypass_logic psw_vpn_clients { $ip timeout 8d }"
                        [ -n "$is_server" ] && echo "add element inet bypass_logic quic_direct_clients { $ip timeout 8d }"
                    fi
                done
            done

            local hid=$(uci -q get dhcp.$section.hostid)
            if [ -n "$v6_prefix" ] && [ -n "$hid" ]; then
                hid=$(echo $hid | sed 's/^://')
                local v6_fixed="${v6_prefix}::${hid}"
                echo "add element inet bypass_logic psw_vpn_clients6 { $v6_fixed }"
                [ -n "$is_server" ] && echo "add element inet bypass_logic quic_direct_clients6 { $v6_fixed }"
            fi
        done
    } | nft -f - 2>/dev/null

    logger -t bypass_guard "Sync: Updated VPN and Server (QUIC-Direct) clients."
}

manage_natmap() {
    local natmap_en="$1"
    local stun_script="/usr/share/bypass_guard/scripts/stun_sync.sh"
    local script_path="/usr/share/bypass_guard/scripts/natmap_bypass.sh"
    local cache_dir="/tmp/natmap_cache"
    local qb_port_file="/tmp/natmap_qb_inner_port"
    local qb_outer_port_file="/tmp/natmap_cache/natmap_last_port"

    # --- ç¬¬ä¸€éƒ¨åˆ†ï¼šSTUN ç‰¹æƒç›´è¿žç®¡ç† ---
    if [ "$natmap_en" -eq 1 ] && [ -f "$stun_script" ]; then
        # 1. åŠ¨æ€åˆå§‹åŒ– STUN é“¾ä¸Žé›†åˆ
        if ! nft list chain inet bypass_logic static_privilege_output >/dev/null 2>&1; then
            nft "add chain inet bypass_logic static_privilege_output { type filter hook output priority -410; policy accept; }" 2>/dev/null
            nft "add set inet bypass_logic stun_direct { type ipv4_addr; flags interval; }" 2>/dev/null
        fi

        # 2. æ³¨å…¥ 3478 ç‰¹æƒè§„åˆ™ï¼ˆå¦‚æžœä¸å­˜åœ¨ï¼‰
        if ! nft list chain inet bypass_logic static_privilege_output | grep -q "STUN-Direct"; then
            nft add rule inet bypass_logic static_privilege_output meta l4proto { tcp, udp } th dport 3478 ip daddr @stun_direct counter accept comment "STUN-Direct-3478"
        fi

        # 3. æ‰§è¡Œç‹¬ç«‹è„šæœ¬ï¼šç»´æŠ¤ STUN IP åˆ—è¡¨
        sh "$stun_script"
    else
        # 4. å¦‚æžœ natmap å…³é—­ï¼Œå½»åº•æ¸…ç† STUN ç›¸å…³å†…æ ¸èµ„æº
        nft delete chain inet bypass_logic static_privilege_output 2>/dev/null
        nft delete set inet bypass_logic stun_direct 2>/dev/null
        logger -t bypass_guard "Sync: STUN privilege resources cleared."
    fi

    if [ -d "$cache_dir" ]; then
        for ext in tcp_fix_rule old_port; do
            ls -t "$cache_dir"/*."$ext" 2>/dev/null | awk '{
                line = "cat " $1; line | getline content; close(line);
                if (content in seen) {
                    system("rm -f " $1); 
                } else {
                    seen[content] = $1;
                }
            }' 2>/dev/null
        done
    fi

    if ! nft list chain inet bypass_logic qb_fix >/dev/null 2>&1; then
        nft "add chain inet bypass_logic qb_fix { type nat hook prerouting priority -110; }" 2>/dev/null
    fi
    if ! nft list set inet bypass_logic qb_outer_ports >/dev/null 2>&1; then
        nft "add set inet bypass_logic qb_outer_ports { type inet_service; }" 2>/dev/null
    fi
    if [ "$natmap_en" -ne 1 ]; then
        local changed=0
        config_load natmap
        do_detach() {
            local section="$1"
            local comment current
            config_get comment "$section" "comment"
            [ "$comment" = "qBittorrent" ] || return 0
            config_get current "$section" "custom_script"
            if [ "$current" = "$script_path" ]; then
                uci set natmap."$section".custom_script=""
                changed=1
            fi
        }
        config_foreach do_detach natmap
        if [ "$changed" -eq 1 ]; then
            uci commit natmap
            /etc/init.d/natmap reload
        fi

        nft flush chain inet bypass_logic qb_fix 2>/dev/null
        nft flush set inet bypass_logic qb_outer_ports 2>/dev/null
        return 0
    fi

    local changed=0
    config_load natmap
    do_attach() {
        local section="$1"
        local comment current
        config_get comment "$section" "comment"
        [ "$comment" = "qBittorrent" ] || return 0
        config_get current "$section" "custom_script"
        if [ "$current" != "$script_path" ]; then
            uci set natmap."$section".custom_script="$script_path"
            changed=1
        fi
    }
    config_foreach do_attach natmap
    if [ "$changed" -eq 1 ]; then
        uci commit natmap
        /etc/init.d/natmap reload
    fi

    local unique_rules=$(cat "$cache_dir"/*.tcp_fix_rule 2>/dev/null | sort -u)
    {
        echo "flush chain inet bypass_logic qb_fix"
        if [ -n "$unique_rules" ]; then
            echo "$unique_rules" | while read -r rule; do
                [ -n "$rule" ] && echo "add rule inet bypass_logic qb_fix $rule"
            done
        fi
    } | nft -f - 2>/dev/null

    if [ -f "$qb_port_file" ]; then
        local p=$(cat "$qb_port_file")
        if [ -n "$p" ]; then
            nft "add element inet bypass_logic qb_dynamic_ports { $p }" 2>/dev/null
            logger -t bypass_guard "Sync: Restored cached qB Port $p"
        fi
    else
        logger -t bypass_guard "Sync: No natmap cache found, skipping port restore"
    fi

    if [ -f "$qb_outer_port_file" ]; then
        local op=$(cat "$qb_outer_port_file")
        if [ -n "$op" ]; then
            nft "add element inet bypass_logic qb_outer_ports { $op }" 2>/dev/null
            logger -t bypass_guard "Sync: Restored cached qB Outer Port $op"
        fi
    else
        logger -t bypass_guard "Sync: No natmap cache found, skipping outer port restore"
    fi
}

refresh_nft() {
    setup_nft
    sync_clients
    update_chnroute
}

start_service() {
    local enabled natmap_en
    config_load "$CONF"
    config_get_bool enabled "$SECTION" "enable_bypass" 0
    config_get_bool natmap_en "$SECTION" "enable_natmap" 0

    if [ "$enabled" -eq 0 ]; then
        logger -t bypass_guard "Service disabled in config. Exiting."
        stop_service
        return 0
    fi

    rm -f "$PSW_DEAD_FLAG"
    logger -t bypass_guard "DEBUG: refresh_nft triggered by [INIT_START]"
    refresh_nft
    manage_natmap "$natmap_en"

    procd_open_instance "psw_monitor"
    procd_set_param command /bin/sh -c '
        fail_cnt=0
        while true; do
            if curl -sk --retry 1 --connect-timeout 2 -I https://www.google.com -o /dev/null; then
                if [ -f "/tmp/psw_dead" ]; then
                    rm -f "/tmp/psw_dead"
                    /etc/init.d/bypass_guard refresh_nft "MONITOR_RECOVERY"
                fi
                fail_cnt=0
            else
                fail_cnt=$((fail_cnt + 1))
                if [ "$fail_cnt" -ge 3 ] && [ ! -f "/tmp/psw_dead" ]; then
                    touch "/tmp/psw_dead"
                    /etc/init.d/bypass_guard refresh_nft "MONITOR_FAILED"
                fi
            fi
            if [ ! -f "/tmp/psw_dead" ]; then
                /etc/init.d/bypass_guard inject_bypass_rule "dstnat"
                /etc/init.d/bypass_guard inject_bypass_rule "mangle_prerouting"
            fi
            sleep 3
        done'
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_set_param respawn
    procd_close_instance
}

stop_service() {
    local natmap_en
    config_load "$CONF"
    config_get_bool natmap_en "$SECTION" "enable_natmap" 0
    remove_bypass_rules
    nft delete table inet bypass_logic 2>/dev/null
    rm -f "$PSW_DEAD_FLAG"
    [ "$natmap_en" -eq 1 ] && manage_natmap 0
}

reload_service() {
    local natmap_en
    config_load "$CONF"
    config_get_bool natmap_en "$SECTION" "enable_natmap" 0
    logger -t bypass_guard "DEBUG: refresh_nft triggered by [RELOAD_FUNC]"
    refresh_nft
    manage_natmap "$natmap_en"
}

service_triggers() {
    procd_add_reload_trigger "passwall2"
    procd_add_reload_trigger "firewall"
    procd_add_reload_trigger "dhcp"
    procd_add_reload_trigger "network"
}
