#!/bin/sh /etc/rc.common
USE_PROCD=1
START=90
EXTRA_COMMANDS="refresh_nft"
CONF="advanced"
SECTION="global"
PSW_DEAD_FLAG="/tmp/psw_dead"

is_chains_ready() {
    nft list chain inet passwall2 mangle_prerouting >/dev/null 2>&1 && \
    nft list chain inet passwall2 dstnat >/dev/null 2>&1
}

remove_bypass_rules() {
    local table="passwall2"
    nft list table inet "$table" >/dev/null 2>&1 || return 0
    local cleaned=0
    for chain in "mangle_prerouting" "dstnat"; do
        nft list chain inet "$table" "$chain" >/dev/null 2>&1 || continue
        local handles=$(nft -a list chain inet "$table" "$chain" 2>/dev/null | grep -E "Bypass-Global-Mark" | awk -F '# handle ' '{print $2}')
        if [ -n "$handles" ]; then
            for handle in $handles; do
                nft delete rule inet "$table" "$chain" handle "$handle" 2>/dev/null
                cleaned=$((cleaned + 1))
            done
        fi
    done
    [ "$cleaned" -gt 0 ] && logger -t bypass_guard "Cleaned up $cleaned residual rules from passwall2."
}

inject_bypass_rule() {
    local table="passwall2"
    local mark="0x000000ff"
    local chain="$1"
    local comment="Bypass-Global-Mark"
    local retries=3
    while [ $retries -gt 0 ]; do
        if nft insert rule inet "$table" "$chain" index 0 meta mark "$mark" counter return comment "$comment" 2>/dev/null; then
            return 0
        fi
        retries=$((retries - 1))
        [ $retries -gt 0 ] && sleep 1
    done
    return 1
}

setup_nft() {
    local is_broken=0
    [ -f "$PSW_DEAD_FLAG" ] && is_broken=1
    local psw_online=$(nft list table inet passwall2 >/dev/null 2>&1 && echo 1 || echo 0)

    nft add table inet bypass_logic 2>/dev/null
    nft flush chain inet bypass_logic prerouting 2>/dev/null || \
    nft "add chain inet bypass_logic prerouting { type filter hook prerouting priority -400; policy accept; }"
    nft flush chain inet bypass_logic qb_fix 2>/dev/null || \
    nft "add chain inet bypass_logic qb_fix { type nat hook prerouting priority -110; }"

    nft "add set inet bypass_logic psw_vpn_clients { type ipv4_addr; flags timeout; }"
    nft "add set inet bypass_logic psw_vpn_clients6 { type ipv6_addr; flags timeout; }"
    nft "add set inet bypass_logic quic_direct_clients { type ipv4_addr; flags timeout; }"
    nft "add set inet bypass_logic quic_direct_clients6 { type ipv6_addr; flags timeout; }"
    nft "add set inet bypass_logic qb_dynamic_ports { type inet_service; flags timeout; }"

    nft add rule inet bypass_logic prerouting tcp dport @qb_dynamic_ports counter meta mark set 0xff accept comment "qB-tcp-dport-Direct"
    nft add rule inet bypass_logic prerouting tcp sport @qb_dynamic_ports counter meta mark set 0xff accept comment "qB-tcp-sport-Direct"
    nft add rule inet bypass_logic prerouting udp dport @qb_dynamic_ports counter meta mark set 0xff accept comment "qB-udp-dport-Direct"
    nft add rule inet bypass_logic prerouting udp sport @qb_dynamic_ports counter meta mark set 0xff accept comment "qB-udp-sport-Direct"

    nft add rule inet bypass_logic prerouting ip saddr @quic_direct_clients tcp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel-tcp-Direct"
    nft add rule inet bypass_logic prerouting ip saddr @quic_direct_clients udp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel-udp-Direct"
    nft add rule inet bypass_logic prerouting ip6 saddr @quic_direct_clients6 tcp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel6-tcp-Direct"
    nft add rule inet bypass_logic prerouting ip6 saddr @quic_direct_clients6 udp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel6-UDP-Direct"

    nft add rule inet bypass_logic prerouting fib daddr type local counter return comment "Local-Fix"
    local lan_addr=$(uci -q get network.lan.ipaddr)
    case "$lan_addr" in
        */*) ;; 
        *) lan_addr="${lan_addr}/24" ;;
    esac
    nft add rule inet bypass_logic prerouting ip daddr "$lan_addr" counter return comment "Loopback-Fix"

    local lan_addr6=$(ip -6 addr show dev br-lan | grep 'scope global' | awk '{print $2}' | head -n1)
    if [ -n "$lan_addr6" ]; then
        nft add rule inet bypass_logic prerouting ip6 daddr "$lan_addr6" counter return comment "Loopback-v6-Fix"
    fi

    if [ "$is_broken" -eq 0 ] && [ "$psw_online" -eq 1 ]; then
        nft add rule inet bypass_logic prerouting ip saddr @psw_vpn_clients counter meta mark set 0 accept comment "AGENT-PASS"
        nft add rule inet bypass_logic prerouting ip6 saddr @psw_vpn_clients6 counter meta mark set 0 accept comment "AGENT-PASS-V6"
        logger -t bypass_guard "ðŸš€ Mode: [PROXY] - Redirecting VPN clients to PassWall2 âœ…"
    else
        logger -t bypass_guard "ðŸ›¡ï¸ Mode: [BYPASS] - PassWall2 is unavailable âš ï¸"
    fi

    nft add rule inet bypass_logic prerouting iifname "br-lan" counter meta mark set 0xff accept comment "Global-Bypass-PassWall2"

    if is_chains_ready; then
        remove_bypass_rules
        local success=0
        inject_bypass_rule "mangle_prerouting" && success=$((success + 1))
        inject_bypass_rule "dstnat" && success=$((success + 1))
        [ "$success" -eq 2 ] && logger -t bypass_guard "ðŸ’‰ Successfully injected all bypass rules into PassWall2 ðŸ’¥"
    else
        return 0
    fi
}

sync_clients() {
    nft flush set inet bypass_logic psw_vpn_clients 2>/dev/null
    nft flush set inet bypass_logic psw_vpn_clients6 2>/dev/null
    nft flush set inet bypass_logic quic_direct_clients 2>/dev/null
    nft flush set inet bypass_logic quic_direct_clients6 2>/dev/null

    local vpn_sections=$(uci show dhcp | grep "@host" | grep "\.tag" | grep -i "VPN" | cut -d. -f2 | sort -u)
    local v6_prefix=$(ip -6 addr show dev br-lan | grep 'scope global' | awk '{print $2}' | cut -d: -f1-4 | head -n1)

    if [ -z "$vpn_sections" ]; then
        logger -t bypass_guard "Sync: No VPN tagged hosts detected."
        return
    fi

    for section in $vpn_sections; do
        local tags=$(uci -q get dhcp.$section.tag)
        local is_server=$(echo "$tags" | grep -iw "server")

        # --- Processing IPv4 ---
        local ips=$(uci -q get dhcp.$section.ip)
        for ip in $ips; do
            [ -z "$ip" ] && continue
            nft "add element inet bypass_logic psw_vpn_clients { $ip timeout 24h }"
            # If it is a server, join the QUIC direct whitelist.
            [ -n "$is_server" ] && nft "add element inet bypass_logic quic_direct_clients { $ip timeout 24h }"
        done

        # --- Handle MAC neighbor synchronization (including IPv6) ---
        local macs=$(uci -q get "dhcp.$section.mac")
        for mac in $macs; do
            local active_ips=$(ip neigh show | grep -i "$mac" | grep -E "REACHABLE|STALE|DELAY" | awk '{print $1}' | grep -v '^fe80')
            for ip in $active_ips; do
                if echo "$ip" | grep -q ':'; then
                    nft "add element inet bypass_logic psw_vpn_clients6 { $ip timeout 24h }" 2>/dev/null
                    [ -n "$is_server" ] && nft "add element inet bypass_logic quic_direct_clients6 { $ip timeout 24h }" 2>/dev/null
                else
                    nft "add element inet bypass_logic psw_vpn_clients { $ip timeout 24h }" 2>/dev/null
                    [ -n "$is_server" ] && nft "add element inet bypass_logic quic_direct_clients { $ip timeout 24h }" 2>/dev/null
                fi
            done
        done

        # --- Processing IPv6 HostID ---
        local hid=$(uci -q get dhcp.$section.hostid)
        if [ -n "$v6_prefix" ] && [ -n "$hid" ]; then
            hid=$(echo $hid | sed 's/^://')
            local v6_fixed="${v6_prefix}::${hid}"
            nft "add element inet bypass_logic psw_vpn_clients6 { $v6_fixed timeout 24h }" 2>/dev/null
            [ -n "$is_server" ] && nft "add element inet bypass_logic quic_direct_clients6 { $v6_fixed timeout 24h }" 2>/dev/null
        fi
    done
    logger -t bypass_guard "Sync: Updated VPN and Server (QUIC-Direct) clients."
}

sync_natmap() {
    if [ -f "/tmp/natmap_qb_outer_port" ]; then
        local p=$(cat /tmp/natmap_qb_outer_port)
        if [ -n "$p" ]; then
            nft "add element inet bypass_logic qb_dynamic_ports { $p timeout 24h }" 2>/dev/null
            logger -t bypass_guard "Sync: Restored cached Outer Port $p from /tmp/natmap_qb_outer_port"
        fi
    else
        logger -t bypass_guard "Sync: No natmap cache found, skipping port restore"
    fi

    local cache_dir="/tmp/natmap_cache"
    nft flush chain inet bypass_logic qb_fix 2>/dev/null
    if [ -d "$cache_dir" ]; then
        for rule_file in "$cache_dir"/*.tcp_fix_rule; do
            [ -e "$rule_file" ] || continue
            local rule_content=$(cat "$rule_file")
            if [ -n "$rule_content" ]; then
                nft "add rule inet bypass_logic qb_fix $rule_content" 2>/dev/null
                logger -t bypass_guard "Sync: Restored TCP Redirect rule: $rule_content"
            fi
        done
    fi
}

refresh_nft() {
    setup_nft
    sync_clients
    sync_natmap
}

start_service() {
    local enabled
    config_load "$CONF"
    config_get_bool enabled "$SECTION" "enable_bypass" 0

    if [ "$enabled" -eq 0 ]; then
        logger -t bypass_guard "Service disabled in config. Exiting."
        stop_service
        return 0
    fi

    setup_nft
    sync_clients
    sync_natmap

    procd_open_instance "psw_monitor"
    procd_set_param command /bin/sh -c '
        fail_cnt=0
        while true; do
            if curl -sk --retry 1 --connect-timeout 2 -I https://www.google.com -o /dev/null; then
                if [ -f "/tmp/psw_dead" ]; then
                    rm -f "/tmp/psw_dead"
                    /etc/init.d/bypass_guard reload
                fi
                fail_cnt=0
            else
                fail_cnt=$((fail_cnt + 1))
                if [ "$fail_cnt" -ge 3 ] && [ ! -f "/tmp/psw_dead" ]; then
                    touch "/tmp/psw_dead"
                    /etc/init.d/bypass_guard reload
                fi
            fi
            sleep 3
        done'
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_set_param respawn
    procd_close_instance
}

stop_service() {
    remove_bypass_rules
    nft delete table inet bypass_logic 2>/dev/null
    rm -f "$PSW_DEAD_FLAG"
}

reload_service() {
    refresh_nft
}

service_triggers() {
    procd_add_reload_trigger "passwall2"
    procd_add_reload_trigger "firewall"
    procd_add_reload_trigger "dhcp"
    procd_add_reload_trigger "network"
}
