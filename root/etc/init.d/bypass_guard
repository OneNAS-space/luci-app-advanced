#!/bin/sh /etc/rc.common
USE_PROCD=1
START=90
EXTRA_COMMANDS="refresh_nft"
CONF="advanced"
SECTION="global"

PSW_DEAD_FLAG="/tmp/psw_dead"

setup_nft() {
    local is_broken=0
    [ -f "$PSW_DEAD_FLAG" ] && is_broken=1
    local psw_online=$(nft list table inet passwall2 >/dev/null 2>&1 && echo 1 || echo 0)

    nft add table inet bypass_logic 2>/dev/null
    nft flush chain inet bypass_logic prerouting 2>/dev/null || \
    nft "add chain inet bypass_logic prerouting { type filter hook prerouting priority -400; policy accept; }"

    nft "add set inet bypass_logic psw_vpn_clients { type ipv4_addr; flags timeout; }"
    nft "add set inet bypass_logic psw_vpn_clients6 { type ipv6_addr; flags timeout; }"
    nft "add set inet bypass_logic quic_direct_clients { type ipv4_addr; flags timeout; }"
    nft "add set inet bypass_logic quic_direct_clients6 { type ipv6_addr; flags timeout; }"
    nft "add set inet bypass_logic qb_dynamic_ports { type inet_service; flags timeout; }"

    nft add rule inet bypass_logic prerouting fib daddr type local counter return comment "Local-Fix"
    local lan_addr=$(uci -q get network.lan.ipaddr)
    case "$lan_addr" in
        */*) ;; 
        *) lan_addr="${lan_addr}/24" ;;
    esac
    nft add rule inet bypass_logic prerouting ip daddr "$lan_addr" counter return comment "Loopback-Fix"

    local lan_addr6=$(ip -6 addr show dev br-lan | grep 'scope global' | awk '{print $2}' | head -n1)
    if [ -n "$lan_addr6" ]; then
        nft add rule inet bypass_logic prerouting ip6 daddr "$lan_addr6" counter return comment "Loopback-v6-Fix"
    fi

    nft add rule inet bypass_logic prerouting ct status dnat counter meta mark set 0xff accept comment "BT-Inbound-Direct"
    nft add rule inet bypass_logic prerouting tcp sport @qb_dynamic_ports counter meta mark set 0xff accept comment "qB-tcp-Direct"
    nft add rule inet bypass_logic prerouting udp sport @qb_dynamic_ports counter meta mark set 0xff accept comment "qB-udp-Direct"

    nft add rule inet bypass_logic prerouting ip saddr @quic_direct_clients tcp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel-tcp-Direct"
    nft add rule inet bypass_logic prerouting ip saddr @quic_direct_clients udp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel-udp-Direct"
    nft add rule inet bypass_logic prerouting ip6 saddr @quic_direct_clients6 tcp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel6-tcp-Direct"
    nft add rule inet bypass_logic prerouting ip6 saddr @quic_direct_clients6 udp dport 7844 counter meta mark set 0xff accept comment "CF-Tunnel6-UDP-Direct"

    if [ "$is_broken" -eq 0 ] && [ "$psw_online" -eq 1 ]; then
        nft add rule inet bypass_logic prerouting ip saddr @psw_vpn_clients counter meta mark set 0 accept comment "AGENT-PASS"
        nft add rule inet bypass_logic prerouting ip6 saddr @psw_vpn_clients6 counter meta mark set 0 accept comment "AGENT-PASS-V6"
        logger -t bypass_guard "Mode: PROXY - Redirecting VPN clients to PassWall2."
    else
        logger -t bypass_guard "Mode: BYPASS - PassWall2 is unavailable."
    fi

    nft add rule inet bypass_logic prerouting iifname "br-lan" counter meta mark set 0xff accept comment "Global-Bypass-PassWall2"

    inject_bypass_rule() {
        local table="passwall2"
        local chain="$1"
        local mark="0x000000ff"
        local handles=$(nft -a list chain inet "$table" "$chain" 2>/dev/null | grep -E "Bypass-Global-Mark" | awk -F '# handle ' '{print $2}')
        if [ -n "$handles" ]; then
            for handle in $handles; do
                nft delete rule inet "$table" "$chain" handle "$handle" 2>/dev/null
            done
        fi
        nft insert rule inet "$table" "$chain" index 0 meta mark "$mark" counter return comment "Bypass-Global-Mark"
    }

    if [ "$psw_online" -eq 1 ]; then
        inject_bypass_rule "mangle_prerouting"
        inject_bypass_rule "dstnat"
        logger -t bypass_guard "Injected bypass rules into PassWall2."
    else
        logger -t bypass_guard "Warning: PassWall2 table not found, skipping injection."
    fi
}

sync_clients() {
    nft flush set inet bypass_logic psw_vpn_clients 2>/dev/null
    nft flush set inet bypass_logic psw_vpn_clients6 2>/dev/null
    nft flush set inet bypass_logic quic_direct_clients 2>/dev/null
    nft flush set inet bypass_logic quic_direct_clients6 2>/dev/null

    local vpn_sections=$(uci show dhcp | grep "@host" | grep "\.tag" | grep -i "VPN" | cut -d. -f2 | sort -u)
    local v6_prefix=$(ip -6 addr show dev br-lan | grep 'scope global' | awk '{print $2}' | cut -d: -f1-4 | head -n1)

    if [ -z "$vpn_sections" ]; then
        logger -t bypass_guard "Sync: No VPN tagged hosts detected."
        return
    fi

    for section in $vpn_sections; do
        local tags=$(uci -q get dhcp.$section.tag)
        local is_server=$(echo "$tags" | grep -iw "server")

        # --- Processing IPv4 ---
        local ips=$(uci -q get dhcp.$section.ip)
        for ip in $ips; do
            [ -z "$ip" ] && continue
            nft "add element inet bypass_logic psw_vpn_clients { $ip timeout 24h }"
            # If it is a server, join the QUIC direct whitelist.
            [ -n "$is_server" ] && nft "add element inet bypass_logic quic_direct_clients { $ip timeout 24h }"
        done

        # --- Handle MAC neighbor synchronization (including IPv6) ---
        local macs=$(uci -q get "dhcp.$section.mac")
        for mac in $macs; do
            local active_ips=$(ip neigh show | grep -i "$mac" | grep -E "REACHABLE|STALE|DELAY" | awk '{print $1}' | grep -v '^fe80')
            for ip in $active_ips; do
                if echo "$ip" | grep -q ':'; then
                    nft "add element inet bypass_logic psw_vpn_clients6 { $ip timeout 24h }" 2>/dev/null
                    [ -n "$is_server" ] && nft "add element inet bypass_logic quic_direct_clients6 { $ip timeout 24h }" 2>/dev/null
                else
                    nft "add element inet bypass_logic psw_vpn_clients { $ip timeout 24h }" 2>/dev/null
                    [ -n "$is_server" ] && nft "add element inet bypass_logic quic_direct_clients { $ip timeout 24h }" 2>/dev/null
                fi
            done
        done

        # --- Processing IPv6 HostID ---
        local hid=$(uci -q get dhcp.$section.hostid)
        if [ -n "$v6_prefix" ] && [ -n "$hid" ]; then
            hid=$(echo $hid | sed 's/^://')
            local v6_fixed="${v6_prefix}::${hid}"
            nft "add element inet bypass_logic psw_vpn_clients6 { $v6_fixed timeout 24h }" 2>/dev/null
            [ -n "$is_server" ] && nft "add element inet bypass_logic quic_direct_clients6 { $v6_fixed timeout 24h }" 2>/dev/null
        fi
    done
    logger -t bypass_guard "Sync: Updated VPN and Server (QUIC-Direct) clients."
}

sync_natmap() {
    if [ -f "/tmp/natmap_qb_outer_port" ]; then
        local p=$(cat /tmp/natmap_qb_outer_port)
        if [ -n "$p" ]; then
            nft "add element inet bypass_logic qb_dynamic_ports { $p timeout 24h }" 2>/dev/null
            logger -t bypass_guard "Sync: Restored cached Outer Port $p from /tmp/natmap_qb_outer_port"
        fi
    else
        logger -t bypass_guard "Sync: No natmap cache found, skipping port restore"
    fi
}

refresh_nft() {
    setup_nft
    sync_clients
    sync_natmap
}

start_service() {
    local enabled
    config_load "$CONF"
    config_get_bool enabled "$SECTION" "enable_guard" 0

    if [ "$enabled" -eq 0 ]; then
        logger -t bypass_guard "Service disabled in config. Exiting."
        stop_service
        return 0
    fi

    setup_nft
    sync_clients
    sync_natmap

    procd_open_instance "psw_monitor"
    procd_set_param command /bin/sh -c '
        fail_cnt=0
        while true; do
            if curl -sk --retry 1 --connect-timeout 2 -I https://www.google.com -o /dev/null; then
                if [ -f "/tmp/psw_dead" ]; then
                    rm -f "/tmp/psw_dead"
                    /etc/init.d/bypass_guard refresh_nft
                fi
                fail_cnt=0
            else
                fail_cnt=$((fail_cnt + 1))
                if [ "$fail_cnt" -ge 3 ] && [ ! -f "/tmp/psw_dead" ]; then
                    touch "/tmp/psw_dead"
                    /etc/init.d/bypass_guard refresh_nft
                fi
            fi
            sleep 3
        done'
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_set_param respawn
    procd_close_instance
}

stop_service() {
    nft delete table inet bypass_logic 2>/dev/null
    rm -f "$PSW_DEAD_FLAG"
}

reload_service() {
    refresh_nft
}

service_triggers() {
    procd_add_reload_trigger "dhcp"
    procd_add_reload_trigger "network"
}
